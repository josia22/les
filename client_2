import socket
import sys
import time
from threading import Thread
import os
import signal
import RPi.GPIO as GPIO
from time import gmtime, strftime

defaultip= input('Vul hier je ip in:')  # This asks for the servers IP adress. This must be entered after the server has been started up otherwise the client won't be able to make a connection

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # This creates a TCP/IP socket
server_address = (defaultip, 10000)                         # This binds the socket to the port
print('connecting to {} port {}'.format(*server_address))
sock.connect(server_address)                                # This connects to the server adress

ip = server_address[0]                                      # This is a variable that is set to zero because it will be changed by the program before usage
message = strftime("%Y-%m-%d %H:%M:%S === no alarm", gmtime())  # This is the message that is sent to the server. Strftime("%Y-%m-%d %H:%M:%S, gmtime()) prints the date and time that the message is sent.
systemstatus = 1                                            # This says that the client is allowed to send an alarm to the server or not. While systemstatus is one the client is allowed to send an alarm


def sending():
    """Sending() is used to send the alarm status to the server"""
    while True:
        try:
            encoded_message = message.encode(encoding='UTF-8')  # The message has to be encoded with UTF-8 so it can be sent to the server
            print('sending {!r}'.format(encoded_message))
            sock.sendall(encoded_message)                       # This sends the message to the server
            while systemstatus == 0:                            # If systemstatus is zero this while loop will ensure that there are no more messages sent to the server
                pass
        finally:
            time.sleep(5)


def receive():
    """Receive() receives the systemstatus and changes if the client is alowed to send alarms to the server"""
    while True:
        global systemstatus
        systemstatus = int(sock.recv(128))                      # This receives messages
        print(systemstatus)
        time.sleep(1)


def ping():
    """"Ping() acts as a heartbeat between the two used systems. By sending a ping every ten seconds the client
    can check is the server is still connected."""
    while True:
        time.sleep(10)
        print('=== attempting ping')
        global ip
        ping = os.system('ping -c 1 '+ str(ip))
        if ping == False:
            print('=== ping succesful')
        else:
            print(strftime("%Y-%m-%d %H:%M:%S === ALARM", gmtime()))
            alarm_activate('Connection lost')


def alarmcheck():
    '''Alarmcheck() runs the alarm when the sensor is pressed.'''
    while True:
        if (GPIO.input(GPIO_Sensor) == False):
            time.sleep(0.5)
            alarm_trigger()


def alarm_trigger():
    '''Alarm_trigger() is activated as a result from a sensor being pressed. Turn it off within 30 seconds to avoid
     the alarm being activated and being sent to the server.'''
    try:
        print('Danger detected, 30 seconds left')
        GPIO.output(GPIO_Green, GPIO.LOW)
        GPIO.output(GPIO_Yellow, GPIO.HIGH)
        signal.alarm(30)
        while True:
            if (GPIO.input(GPIO_Button) == False):
                time.sleep(0.5)
                print('Alarm turning off. Alarm shutting down at Server.')
                signal.alarm(0)
                GPIO.output(GPIO_Green, GPIO.HIGH)
                GPIO.output(GPIO_Yellow, GPIO.LOW)
                time.sleep(0.2)
                break
    except TimeoutException:
        print()
        print('Button press time out.')
        alarm_activate('Sensor pressed')


def alarm_activate(reason):
    '''The alarm is being activated and being sent to the server. You can still turn it off, but the alarm was
    reveived by the server so it is dealt with by the support.'''
    print('Alarm initiated')
    print('Reason: ' + reason)
    time.time()
    GPIO.output(GPIO_Green, GPIO_LOW)   # Green light is turned off
    GPIO.output(GPIO_Yellow, GPIO.LOW)  # Yellow light is turned off
    GPIO.output(GPIO_Red, GPIO.HIGH)    # Red light is turned on
    global message
    message = strftime("%Y-%m-%d %H:%M:%S === ALARM", gmtime())     # Alarm messages being sent to the server
    while True:
        if (GPIO.input(GPIO_Button) == False):      # Alarm is turned off client side by pressing the button
            time.sleep(0.5)
            print('Alarm turning off. Alarm still on at server. Contact support.')
            GPIO.output(GPIO_Green, GPIO.HIGH)      # Green light on
            GPIO.output(GPIO_Red, GPIO.LOW)         # Red light off
            time.sleep(0.2)
            global message
            message = strftime("%Y-%m-%d %H:%M:%S === no alarm", gmtime()) # No alarm messages being sent by the client
            break


if __name__ == '__main__':
    #This part of the code runs all the functions above
        #First the pins on the RaspberryPi are asigned to the correct variables
        #Then the functions are multithreaded. This has been put on a delay of ten seconds to make sure that the pins
        #have been asigned propperly

    class TimeoutException(Exception):  # Custom exception class
        pass

    def timeout_handler(signum, frame): # Custom signal handler
        raise TimeoutException

    signal.signal(signal.SIGALRM, timeout_handler)

    GPIO.setmode(GPIO.BCM)              # Setting the right mode for the GPIO pins to function
    GPIO.setwarnings(False)             # Making sure no warnings show when running

    GPIO_Button = 2     # pin 3            # Determine the correct pin corresponding the lights and buttons
    GPIO_Sensor = 3     # pin 5
    GPIO_Green = 26     # pin 37
    GPIO_Yellow = 18    # pin 12
    GPIO_Red = 12       # pin 33

    GPIO.setup(GPIO_Button, GPIO.IN, pull_up_down=GPIO.PUD_UP)  # Setting up the GPIO pins
    GPIO.setup(GPIO_Sensor, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(GPIO_Green, GPIO.OUT)
    GPIO.setup(GPIO_Yellow, GPIO.OUT)
    GPIO.setup(GPIO_Red, GPIO.OUT)

    GPIO.output(GPIO_Green, GPIO.LOW)   # Being sure all the lights are out when first
    GPIO.output(GPIO_Yellow, GPIO.LOW)  # running the program
    GPIO.output(GPIO_Red, GPIO.LOW)

    GPIO.output(GPIO_Green, GPIO.HIGH)  # The alarm is running, so the green lamp is on.

    print('generic alarm system')
    print('system: client')
    print('client booting up')
    time.sleep(10)
    t1 = Thread(target=sending)         # The functions are asigned their own threads
    t2 = Thread(target=ping)
    t3 = Thread(target=receive)
    t1.setDaemon(True)
    t2.setDaemon(True)
    t3.setDaemon(True)
    t1.start()                          # Each thread is started up
    t2.start()
    t3.start()
    print('client booted')
    alarmcheck()                        # The alarmcheck() is being run outside of a thread because the signal imort and the threading import don't work propperly together
    while True:                         # This while-loop is so that the client doesn't close itself after having booted all the threads
        pass
